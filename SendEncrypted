using System;
using System.IO;
using System.Net;
using System.Net.Mail;
using System.Security.Cryptography;
using System.Text;

namespace SendEncrypted
{
    class Program
    {
        static void Main(string[] args)
        {
            //user confiruration
            string username = "";
            string password = "";
            string host = "";
            int port = 0;
            bool ssl = false;
            
            //user private and public key string
            string privateKey = "";
            string publicKey = "";

            //search for profile file
            string profilePath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\SendEncrypted\profile.txt";
            string privateKeyPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\SendEncrypted\private.txt";
            string publicKeyPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\SendEncrypted\public.txt";
  
            if(File.Exists(profilePath) && File.Exists(privateKeyPath) && File.Exists(publicKeyPath))
            {
                //read profile file
                using (StringReader sr = new StringReader(File.ReadAllText(profilePath))) 
                {
                    string line;
                    while ((line = sr.ReadLine()) != null) 
                    {                        
                        if(line.Substring(0,4) == "ssl:")
                        {
                            string dump = line.Substring(4).Trim();
                            if(dump == "True")
                            {
                                ssl = true;
                            }
                        }
                        else if (line.Substring(0, 5) == "host:")
                        {
                            host = line.Substring(5).Trim();
                        }
                        else if (line.Substring(0, 5) == "port:")
                        {
                            port = Int32.Parse(line.Substring(5).Trim());
                        }
                        else if (line.Substring(0, 9) == "username:")
                        {
                            username = line.Substring(9).Trim();
                        }
                    }
                }

                //password is used to encrpyt private key with AES
                Console.Write("Please enter password for " + username + ": ");
                password = ReadPassword();

                //preberemo private key file
                string rawPrivateKey = File.ReadAllText(privateKeyPath);

                //decrypt private key using user password
                privateKey = DecryptStringAes(rawPrivateKey, ConvertKey(password));

                //read public key
                publicKey = File.ReadAllText(publicKeyPath);

            }
            else //create new identity
            {
                Console.Write("Your username: ");
                username = Console.ReadLine();
                Console.Write("Your password: ");
                password = ReadPassword();
                Console.Write("Your host: ");
                host = Console.ReadLine();
                Console.Write("Your port: ");
                port = Int32.Parse(Console.ReadLine());
                Console.Write("Use ssl (true/false): ");
                ssl = Boolean.Parse(Console.ReadLine());

                //save data to profile.txt
                string[] lines = { "username:" + username, "host:" + host, "port:" + port, "ssl:" + ssl};
                File.WriteAllLines(profilePath, lines);

                //create new RSA key and save it to file
                GenerateRSAKey(password, privateKeyPath, publicKeyPath);

                //read from created file to variables
                string rawPrivateKey = File.ReadAllText(privateKeyPath);

                privateKey = DecryptStringAes(rawPrivateKey, ConvertKey(password));

                publicKey = File.ReadAllText(publicKeyPath);


            }

            //for debuging only
            Console.WriteLine(username);
            Console.WriteLine(password);
            Console.WriteLine(port);
            Console.WriteLine(host);
            Console.WriteLine(ssl);

            Console.WriteLine(privateKey);
            Console.WriteLine(publicKey);

            Console.WriteLine();
            Console.WriteLine();

            /*
             *  USER CREDENTIALS: LOADED!
             * 
             *  SENDING EMAIL...
             * 
             */

            

            //set the receiver
            Console.WriteLine("Enter receiver: ");
            string toMail = Console.ReadLine();

            /* TO-DO:
             * GET RECEIVER PUBLIC KEY FROM ADDRESSER
             * DECODE BASE64 TO GET "STRING" FOR THE FUNCTION encryptRsa
             * 
             */

            /*
             * FOR NOW IT JUST SIGN THE MESSAGE AND ENCRPYT IT
             * IT APPEND SIGN AND PUBLIC KEY AT THE END
             * 
             * 
             */

            Console.WriteLine("Enter message: ");
            string message = Console.ReadLine();


            string body = "---MESSAGE---" + Environment.NewLine + message + Environment.NewLine + "---END_MESSAGE---" + Environment.NewLine + "---SIGNATURE---" + Environment.NewLine + Base64Encode(signMessage(privateKey, message)) + Environment.NewLine
                + "---END_SIGNATURE---" + Environment.NewLine + "---PUBLIC_KEY---" + Environment.NewLine + Base64Encode(publicKey) + Environment.NewLine + "---END_PUBLIC_KEY---";

            string output = sendit(username, password, toMail, body, host, port, ssl);
            Console.WriteLine();
            Console.WriteLine(output);
            Console.ReadLine();
        }

        //read password from cmd (get * instead of real chars)
        public static string ReadPassword()
        {
            string password = "";
            ConsoleKeyInfo info = Console.ReadKey(true);
            while (info.Key != ConsoleKey.Enter)
            {
                if (info.Key != ConsoleKey.Backspace)
                {
                    Console.Write("*");
                    password += info.KeyChar;
                }
                else if (info.Key == ConsoleKey.Backspace)
                {
                    if (!string.IsNullOrEmpty(password))
                    {
                        // remove one character from the list of password characters
                        password = password.Substring(0, password.Length - 1);
                        // get the location of the cursor
                        int pos = Console.CursorLeft;
                        // move the cursor to the left by one character
                        Console.SetCursorPosition(pos - 1, Console.CursorTop);
                        // replace it with space
                        Console.Write(" ");
                        // move the cursor to the left by one character again
                        Console.SetCursorPosition(pos - 1, Console.CursorTop);
                    }
                }
                info = Console.ReadKey(true);
            }
            // add a new line because user pressed enter at the end of their password
            Console.WriteLine();
            return password;
        }

        //convert password to bytes for AES encryption
        private static byte[] ConvertKey(string password, int keyBytes = 32)
        {
            const int Iterations = 300;
            byte[] Salt = new byte[] { 10, 20, 30 , 40, 50, 60, 70, 80};
            var keyGenerator = new Rfc2898DeriveBytes(password, Salt, Iterations);
            return keyGenerator.GetBytes(keyBytes);
        }

        //encrpyt privateKey using password bytes from ConvertKey
        static string EncryptStringAes(string plainText, byte[] Key)
        {
            // Check arguments. 
            if (plainText == null || plainText.Length <= 0)
                throw new ArgumentNullException("plainText");
            if (Key == null || Key.Length <= 0)
                throw new ArgumentNullException("Key");

            string output = "";
            byte[] encrypted;
            // Create an AesManaged object 
            // with the specified key and IV. 
            using (AesManaged aesAlg = new AesManaged())
            {
                aesAlg.Key = Key;

                // Create a decrytor to perform the stream transform.
                ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);

                // Create the streams used for encryption. 
                using (MemoryStream msEncrypt = new MemoryStream())
                {
                    using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                    {
                        using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                        {

                            //Write all data to the stream.
                            swEncrypt.Write(plainText);
                        }
                        encrypted = msEncrypt.ToArray();
                    }
                }
                string cipherText = Convert.ToBase64String(encrypted);
                string IV = Convert.ToBase64String(aesAlg.IV);
                output = IV + cipherText;
            }


            // Return the encrypted bytes from the memory stream. 
            return output;

        }

        //decrypt privateKey using password bytes
        static string DecryptStringAes(string cipherTextString, byte[] Key)
        {
            string IV_String = cipherTextString.Substring(0, 24);
            string cipher_String = cipherTextString.Substring(24);
            byte[] cipherText = Convert.FromBase64String(cipher_String);
            byte[] IV = Convert.FromBase64String(IV_String);

            // Check arguments. 
            if (cipherText == null || cipherText.Length <= 0)
                throw new ArgumentNullException("cipherText");
            if (Key == null || Key.Length <= 0)
                throw new ArgumentNullException("Key");
            if (IV == null || IV.Length <= 0)
                throw new ArgumentNullException("Key");

            //razbijemo cipherText


            // Declare the string used to hold 
            // the decrypted text. 
            string plaintext = null;

            // Create an AesManaged object 
            // with the specified key and IV. 
            using (AesManaged aesAlg = new AesManaged())
            {
                aesAlg.Key = Key;
                aesAlg.IV = IV;

                // Create a decrytor to perform the stream transform.
                ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);

                // Create the streams used for decryption. 
                using (MemoryStream msDecrypt = new MemoryStream(cipherText))
                {
                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                    {
                        using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                        {

                            // Read the decrypted bytes from the decrypting stream 
                            // and place them in a string.
                            plaintext = srDecrypt.ReadToEnd();
                        }
                    }
                }

            }

            return plaintext;

        }

        //generate new RSA key pair and save them to files
        static void GenerateRSAKey(string password, string privateKeyPath, string publicKeyPath)
        {
            //generate new RSA key pair
            var ServiceProvider = new RSACryptoServiceProvider(2048);

            //ger private and public key
            var privateKey = ServiceProvider.ExportParameters(true);
            var publicKey = ServiceProvider.ExportParameters(false);

            //write private key to file
            var stringWriter = new System.IO.StringWriter();
            var xmlSerializer = new System.Xml.Serialization.XmlSerializer(typeof(RSAParameters));
            xmlSerializer.Serialize(stringWriter, privateKey);
            string privateKeyString = stringWriter.ToString();

            File.WriteAllText(privateKeyPath, EncryptStringAes(privateKeyString, ConvertKey(password)));

            //write public key to file
            stringWriter = new System.IO.StringWriter();
            xmlSerializer = new System.Xml.Serialization.XmlSerializer(typeof(RSAParameters));
            xmlSerializer.Serialize(stringWriter, publicKey);
            string publicKeyString = stringWriter.ToString();

            File.WriteAllText(publicKeyPath, publicKeyString);

        }

        //generate hash and encrypt it using privateKey
        static string signMessage(string privateKeyString, string message)
        {
            //get private key and message from files

            //from string to object
            var stringReader = new System.IO.StringReader(privateKeyString);
            var xmlSerializer = new System.Xml.Serialization.XmlSerializer(typeof(RSAParameters));
            var privateKey = (RSAParameters)xmlSerializer.Deserialize(stringReader);

            var serviceProvider = new RSACryptoServiceProvider();
            serviceProvider.ImportParameters(privateKey);

            //get signature
            RSAPKCS1SignatureFormatter formatter = new RSAPKCS1SignatureFormatter(serviceProvider);
            formatter.SetHashAlgorithm("SHA256");
            SHA256Managed SHhash = new SHA256Managed();
            byte[] signedValue = formatter.CreateSignature(SHhash.ComputeHash(new UnicodeEncoding().GetBytes(message)));

            //write string to output file
            string signature = System.Convert.ToBase64String(signedValue);
            return signature;
        }

        //signatures, keys can containst \n what makes akward new lines in message, so we convert them to base64
        public static string Base64Encode(string plainText)
        {
            var plainTextBytes = System.Text.Encoding.UTF8.GetBytes(plainText);
            return System.Convert.ToBase64String(plainTextBytes);
        }

        //NOT USED: from received message we convert back public key and signature
        public static string Base64Decode(string base64EncodedData)
        {
            var base64EncodedBytes = System.Convert.FromBase64String(base64EncodedData);
            return System.Text.Encoding.UTF8.GetString(base64EncodedBytes);
        }

        //Send message using SMTP
        public static string sendit(string username, string password, string toMail, string message, string host, int port, bool ssl)
        {
            MailMessage msg = new MailMessage();

            msg.From = new MailAddress(username);
            msg.To.Add(toMail);
            msg.Subject = "Encrpyted on: " + DateTime.Now.ToString();
            msg.Body = message;

            SmtpClient client = new SmtpClient();
            client.Host = host; //smtp.gmail.com
            client.Port = port; // 587
            client.EnableSsl = ssl; //true
            client.DeliveryMethod = SmtpDeliveryMethod.Network;
            client.UseDefaultCredentials = false;
            client.Credentials = new NetworkCredential(username, password);

            client.Timeout = 20000;
            try
            {
                client.Send(msg);
                return "Mail has been successfully sent!";
            }
            catch (Exception ex)
            {
                return "Fail Has error" + ex.Message;
            }
            finally
            {
                msg.Dispose();
            }
        }

        //encrpyt string RSA key (for now only for signature), to-do encrypt message using receiver's public key
        public static string encryptRsa(string publicKeyLoc, string message)
        {
            //read public key from file
            string pubicKeyString = File.ReadAllText(publicKeyLoc);

            //read plaintext message from file
            string text = message;

            //from string to object
            var stringReader = new System.IO.StringReader(pubicKeyString);
            var xmlSerializer = new System.Xml.Serialization.XmlSerializer(typeof(RSAParameters));
            var pubicKey = (RSAParameters)xmlSerializer.Deserialize(stringReader);

            var serviceProvider = new RSACryptoServiceProvider();
            serviceProvider.ImportParameters(pubicKey);

            //encrypt plain text
            var bytesPlainText = System.Text.Encoding.Unicode.GetBytes(text);
            var bytesCypher = serviceProvider.Encrypt(bytesPlainText, false);
            var cypher = Convert.ToBase64String(bytesCypher);

            //write encrypted text back to output file
            return cypher;
        }
    }
}
