using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net.Mail;
using System.Net;
using System.IO;
using System.Security.Cryptography;

namespace SendEncrypted
{
    class Program
    {
        static void Main(string[] args)
        {
            //configuration
            string username = "";
            string password = "";
            string host = "";
            int port = 0;
            bool ssl = false;

            string privateKey = "";
            string publicKey = "";

            //search for profile file
            string profilePath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\SendEncrypted\profile.txt";
            string privateKeyPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\SendEncrypted\private.txt";
            string publicKeyPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\SendEncrypted\public.txt";
  
            if(File.Exists(profilePath) && File.Exists(privateKeyPath) && File.Exists(publicKeyPath))
            {
                //preberemo profile file
                using (StringReader sr = new StringReader(File.ReadAllText(profilePath))) 
                {
                    string line;
                    while ((line = sr.ReadLine()) != null) 
                    {                        
                        if(line.Substring(0,4) == "ssl:")
                        {
                            string dump = line.Substring(4).Trim();
                            if(dump == "True")
                            {
                                ssl = true;
                            }
                        }
                        else if (line.Substring(0, 5) == "host:")
                        {
                            host = line.Substring(5).Trim();
                        }
                        else if (line.Substring(0, 5) == "port:")
                        {
                            port = Int32.Parse(line.Substring(5).Trim());
                        }
                        else if (line.Substring(0, 9) == "username:")
                        {
                            username = line.Substring(9).Trim();
                        }
                    }
                }
                Console.Write("Please enter password for " + username + ": ");
                password = ReadPassword();

                //preberemo private key file
                string rawPrivateKey = File.ReadAllText(privateKeyPath);

                privateKey = DecryptStringAes(rawPrivateKey, ConvertKey(password));

                publicKey = File.ReadAllText(publicKeyPath);

            }
            else
            {
                Console.Write("Your username: ");
                username = Console.ReadLine();
                Console.Write("Your password: ");
                password = ReadPassword();
                Console.Write("Your host: ");
                host = Console.ReadLine();
                Console.Write("Your port: ");
                port = Int32.Parse(Console.ReadLine());
                Console.Write("Use ssl (true/false): ");
                ssl = Boolean.Parse(Console.ReadLine());

                string[] lines = { "username:" + username, "host:" + host, "port:" + port, "ssl:" + ssl};
                // WriteAllLines creates a file, writes a collection of strings to the file,
                // and then closes the file.  You do NOT need to call Flush() or Close().
                File.WriteAllLines(profilePath, lines);

                GenerateRSAKey(password, privateKeyPath, publicKeyPath);

                string rawPrivateKey = File.ReadAllText(privateKeyPath);

                privateKey = DecryptStringAes(rawPrivateKey, ConvertKey(password));

                publicKey = File.ReadAllText(publicKeyPath);


            }

            Console.WriteLine(username);
            Console.WriteLine(password);
            Console.WriteLine(port);
            Console.WriteLine(host);
            Console.WriteLine(ssl);
            Console.WriteLine(privateKey);
            Console.WriteLine(publicKey);

            //uporabni≈°ke nastavitve nastavljene :)

            Console.WriteLine();
            Console.WriteLine();

            //posiljamo mail !!
            Console.WriteLine("Enter receiver: ");
            string toMail = Console.ReadLine();

            //to-do poiscemo njegov javni kljuc v addressarju.

            Console.WriteLine("Enter message: ");
            string message = Console.ReadLine();


            string body = "--------MESSAGE-------" + Environment.NewLine + message + "---------END_MESSAGE---------" + Environment.NewLine + "---------------SIGNATURE---------" + Environment.NewLine + signMessage(privateKey, message) + Environment.NewLine
                + "--------------END_SIGNATURE-------------" + Environment.NewLine + "----------PUBLIC_KEY---------------" + Environment.NewLine + publicKey + Environment.NewLine + "------------END_PUBLIC_KEY----------------";

            string output = sendit(username, password, toMail, body, host, port, ssl);
            Console.ReadLine();
        }

        public static string ReadPassword()
        {
            string password = "";
            ConsoleKeyInfo info = Console.ReadKey(true);
            while (info.Key != ConsoleKey.Enter)
            {
                if (info.Key != ConsoleKey.Backspace)
                {
                    Console.Write("*");
                    password += info.KeyChar;
                }
                else if (info.Key == ConsoleKey.Backspace)
                {
                    if (!string.IsNullOrEmpty(password))
                    {
                        // remove one character from the list of password characters
                        password = password.Substring(0, password.Length - 1);
                        // get the location of the cursor
                        int pos = Console.CursorLeft;
                        // move the cursor to the left by one character
                        Console.SetCursorPosition(pos - 1, Console.CursorTop);
                        // replace it with space
                        Console.Write(" ");
                        // move the cursor to the left by one character again
                        Console.SetCursorPosition(pos - 1, Console.CursorTop);
                    }
                }
                info = Console.ReadKey(true);
            }
            // add a new line because user pressed enter at the end of their password
            Console.WriteLine();
            return password;
        }

        private static byte[] ConvertKey(string password, int keyBytes = 32)
        {
            const int Iterations = 300;
            byte[] Salt = new byte[] { 10, 20, 30 , 40, 50, 60, 70, 80};
            var keyGenerator = new Rfc2898DeriveBytes(password, Salt, Iterations);
            return keyGenerator.GetBytes(keyBytes);
        }

        static string EncryptStringAes(string plainText, byte[] Key)
        {
            // Check arguments. 
            if (plainText == null || plainText.Length <= 0)
                throw new ArgumentNullException("plainText");
            if (Key == null || Key.Length <= 0)
                throw new ArgumentNullException("Key");

            string output = "";
            byte[] encrypted;
            // Create an AesManaged object 
            // with the specified key and IV. 
            using (AesManaged aesAlg = new AesManaged())
            {
                aesAlg.Key = Key;

                // Create a decrytor to perform the stream transform.
                ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);

                // Create the streams used for encryption. 
                using (MemoryStream msEncrypt = new MemoryStream())
                {
                    using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                    {
                        using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                        {

                            //Write all data to the stream.
                            swEncrypt.Write(plainText);
                        }
                        encrypted = msEncrypt.ToArray();
                    }
                }
                string cipherText = Convert.ToBase64String(encrypted);
                string IV = Convert.ToBase64String(aesAlg.IV);
                output = IV + cipherText;
            }


            // Return the encrypted bytes from the memory stream. 
            return output;

        }

        static string DecryptStringAes(string cipherTextString, byte[] Key)
        {
            string IV_String = cipherTextString.Substring(0, 24);
            string cipher_String = cipherTextString.Substring(24);
            byte[] cipherText = Convert.FromBase64String(cipher_String);
            byte[] IV = Convert.FromBase64String(IV_String);

            // Check arguments. 
            if (cipherText == null || cipherText.Length <= 0)
                throw new ArgumentNullException("cipherText");
            if (Key == null || Key.Length <= 0)
                throw new ArgumentNullException("Key");
            if (IV == null || IV.Length <= 0)
                throw new ArgumentNullException("Key");

            //razbijemo cipherText


            // Declare the string used to hold 
            // the decrypted text. 
            string plaintext = null;

            // Create an AesManaged object 
            // with the specified key and IV. 
            using (AesManaged aesAlg = new AesManaged())
            {
                aesAlg.Key = Key;
                aesAlg.IV = IV;

                // Create a decrytor to perform the stream transform.
                ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);

                // Create the streams used for decryption. 
                using (MemoryStream msDecrypt = new MemoryStream(cipherText))
                {
                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                    {
                        using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                        {

                            // Read the decrypted bytes from the decrypting stream 
                            // and place them in a string.
                            plaintext = srDecrypt.ReadToEnd();
                        }
                    }
                }

            }

            return plaintext;

        }

        static void GenerateRSAKey(string password, string privateKeyPath, string publicKeyPath)
        {
            //generate new RSA key pair
            var ServiceProvider = new RSACryptoServiceProvider(2048);

            //ger private and public key
            var privateKey = ServiceProvider.ExportParameters(true);
            var publicKey = ServiceProvider.ExportParameters(false);

            //write private key to file
            var stringWriter = new System.IO.StringWriter();
            var xmlSerializer = new System.Xml.Serialization.XmlSerializer(typeof(RSAParameters));
            xmlSerializer.Serialize(stringWriter, privateKey);
            string privateKeyString = stringWriter.ToString();

            File.WriteAllText(privateKeyPath, EncryptStringAes(privateKeyString, ConvertKey(password)));

            //write public key to file
            stringWriter = new System.IO.StringWriter();
            xmlSerializer = new System.Xml.Serialization.XmlSerializer(typeof(RSAParameters));
            xmlSerializer.Serialize(stringWriter, publicKey);
            string publicKeyString = stringWriter.ToString();

            File.WriteAllText(publicKeyPath, publicKeyString);

        }

        static string signMessage(string privateKeyString, string message)
        {
            //get private key and message from files

            //from string to object
            var stringReader = new System.IO.StringReader(privateKeyString);
            var xmlSerializer = new System.Xml.Serialization.XmlSerializer(typeof(RSAParameters));
            var privateKey = (RSAParameters)xmlSerializer.Deserialize(stringReader);

            var serviceProvider = new RSACryptoServiceProvider();
            serviceProvider.ImportParameters(privateKey);

            //get signature
            RSAPKCS1SignatureFormatter formatter = new RSAPKCS1SignatureFormatter(serviceProvider);
            formatter.SetHashAlgorithm("SHA256");
            SHA256Managed SHhash = new SHA256Managed();
            byte[] signedValue = formatter.CreateSignature(SHhash.ComputeHash(new UnicodeEncoding().GetBytes(message)));

            //write string to output file
            string signature = System.Convert.ToBase64String(signedValue);
            return signature;
        }

        public static string sendit(string username, string password, string toMail, string message, string host, int port, bool ssl)
        {
            MailMessage msg = new MailMessage();

            msg.From = new MailAddress(username);
            msg.To.Add(toMail);
            msg.Subject = "Encrpyted on: " + DateTime.Now.ToString();
            msg.Body = message;

            SmtpClient client = new SmtpClient();
            client.Host = host; //smtp.gmail.com
            client.Port = port; // 587
            client.EnableSsl = ssl; //true
            client.DeliveryMethod = SmtpDeliveryMethod.Network;
            client.UseDefaultCredentials = false;
            client.Credentials = new NetworkCredential(username, password);

            client.Timeout = 20000;
            try
            {
                client.Send(msg);
                return "Mail has been successfully sent!";
            }
            catch (Exception ex)
            {
                return "Fail Has error" + ex.Message;
            }
            finally
            {
                msg.Dispose();
            }
        }

        public static string encrypt(string publicKeyLoc, string message)
        {
            //read public key from file
            string pubicKeyString = File.ReadAllText(publicKeyLoc);

            //read plaintext message from file
            string text = message;

            //from string to object
            var stringReader = new System.IO.StringReader(pubicKeyString);
            var xmlSerializer = new System.Xml.Serialization.XmlSerializer(typeof(RSAParameters));
            var pubicKey = (RSAParameters)xmlSerializer.Deserialize(stringReader);

            var serviceProvider = new RSACryptoServiceProvider();
            serviceProvider.ImportParameters(pubicKey);

            //encrypt plain text
            var bytesPlainText = System.Text.Encoding.Unicode.GetBytes(text);
            var bytesCypher = serviceProvider.Encrypt(bytesPlainText, false);
            var cypher = Convert.ToBase64String(bytesCypher);

            //write encrypted text back to output file
            return cypher;
        }
    }
}
